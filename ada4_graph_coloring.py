# -*- coding: utf-8 -*-
"""ADA4 Graph Coloring.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MdS7bpm9XNQDVkYr7d6-DB9CCVOag1T3
"""

V = 4

def print_solution(color):
    print("Solution Exists: Following are the assigned colors")
    print(" ".join(map(str, color)))

def is_safe(v, graph, color, c):

    for i in range(V):
        if graph[v][i] and c == color[i]:
            return False
    return True

def graph_coloring_util(graph, m, color, v):

    if v == V:
        return True

    for c in range(1, m + 1):

        if is_safe(v, graph, color, c):
            color[v] = c


            if graph_coloring_util(graph, m, color, v + 1):
                return True


            color[v] = 0


    return False

def graph_coloring(graph, m):
    color = [0] * V


    if not graph_coloring_util(graph, m, color, 0):
        print("Solution does not exist")
        return False


    print_solution(color)
    return True

def m_coloring(graph, m):

    color = [0] * V
    return graph_coloring(graph, m)

def get_coordinates(graph):

    print("Vertices Coordinates:")
    for v in range(V):
        print(f"Vertex {v}: Coordinates (x, y)")

def print_menu():

    print("\nGraph Coloring Menu")
    print("1. Check m-coloring")
    print("2. Display Graph Coordinates")
    print("3. Exit")

def main():
    graph = [
        [0, 1, 1, 1],
        [1, 0, 1, 0],
        [1, 1, 0, 1],
        [1, 0, 1, 0],
    ]

    while True:
        print_menu()
        choice = input("Enter your choice: ")

        if choice == '1':
            m = int(input("Enter the number of colors: "))
            if not m_coloring(graph, m):
                print("No solution found with the given number of colors.")
        elif choice == '2':
            get_coordinates(graph)
        elif choice == '3':
            print("Exiting the program.")
            break
        else:
            print("Invalid choice. Please try again.")


if __name__ == "__main__":
    main()

class Graph:
    def __init__(self, vertices):
        self.V = vertices  # Number of vertices
        self.graph = [[0 for _ in range(vertices)] for _ in range(vertices)]

    def add_edge(self, u, v):
        # Undirected graph, so set both [u][v] and [v][u] to 1
        self.graph[u][v] = 1
        self.graph[v][u] = 1

    def is_safe(self, v, color, result):
        # Check if the adjacent vertices have the same color
        for i in range(self.V):
            if self.graph[v][i] == 1 and result[i] == color:
                return False
        return True

    def graph_coloring_util(self, m, result, v):
        if v == self.V:  # All vertices are colored
            return True

        for color in range(m):  # Try all colors from 0 to m-1
            if self.is_safe(v, color, result):
                result[v] = color
                if self.graph_coloring_util(m, result, v + 1):
                    return True
                result[v] = -1  # Backtrack

        return False

    def graph_coloring(self, m):
        result = [-1] * self.V
        if not self.graph_coloring_util(m, result, 0):
            print("Solution does not exist")
            return False

        print("Solution exists: Following are the assigned frequencies (colors)")
        for u in range(self.V):
            print(f"Station {u} --> Frequency {result[u]}")
        return True


if __name__ == "__main__":
    g = Graph(5)
    g.add_edge(0, 1)
    g.add_edge(0, 2)
    g.add_edge(1, 2)
    g.add_edge(1, 3)
    g.add_edge(2, 4)

    m = 3  # Number of available frequencies (colors)
    g.graph_coloring(m)

"""
Time complexity = O(V^M)
Space complexity = O(V^2) for V*V adjacency matrix
This is because each vertex V has M colour choices, and we try all combinations.
"""

class Graph:
    def __init__(self, vertices):
        self.V = vertices
        self.graph = []

    def add_edge(self, u, v):
        while len(self.graph) <= max(u, v):
            self.graph.append([])

        self.graph[u].append(v)
        self.graph[v].append(u)

    def greedy_coloring(self):
        result = [-1] * self.V
        result[0] = 0
        available = [True] * self.V

        for u in range(1, self.V):
            # Mark unavailable colors for adjacent vertices
            for i in self.graph[u]:
                if result[i] != -1:
                    available[result[i]] = False

            # Find the first available color
            color = 0
            while color < self.V:
                if available[color]:
                    break
                color += 1

            # Assign the found color to the vertex u
            result[u] = color

            # Reset the available list for the next iteration
            available = [True] * self.V

        # Print the result
        for u in range(self.V):
            print(f"Station {u} --> Frequency {result[u]}")


if __name__ == "__main__":
    g = Graph(5)
    g.add_edge(0, 1)
    g.add_edge(0, 2)
    g.add_edge(1, 2)
    g.add_edge(1, 3)
    g.add_edge(2, 4)
    g.greedy_coloring()