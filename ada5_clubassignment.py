# -*- coding: utf-8 -*-
"""5_ADA_ClubAssignment.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14sv1Y4mG8Qnb1P1X9gepw1VOnxihwrol
"""

import heapq
import copy

class Node:

    def __init__(self, stud, club, assigned, parent):

        self.parent = parent
        self.pathCost = 0
        self.cost = 0
        self.studID = stud
        self.clubID = club
        self.assigned = copy.deepcopy(assigned)

        if club !=-1:
            self.assigned[club] = True

    # Define the __lt__ method to enable comparison between Node objects
    def __lt__(self, other):
        # Compare based on cost; you might need to adjust this based on your specific needs
        return self.cost < other.cost

class CustomHeap:

    def __init__(self):
        self.heap = []

    def push(self, node):
        heapq.heappush(self.heap, (node.cost, node))

    def pop(self):

        if self.heap:
            _, node = heapq.heappop(self.heap)
            return node
        return None


def new_node(stud, club, assigned, parent):
    return Node(stud, club, assigned, parent)

def calc_cost(cost_mat, stud, club, assigned):

    cost = 0
    available = [True] * N

    for i in range(stud + 1, N):
        min_val, min_index = float('inf'),-1

        for j in range(N):
            if not assigned[j] and available[j] and cost_mat[i][j] < min_val:
                min_index = j
                min_val = cost_mat[i][j]

        cost += min_val
        available[min_index] = False

    return cost

def print_assignmts(min_node):

    if min_node.parent is None:
        return

    print_assignmts(min_node.parent)
    print(f"Assign student {chr(min_node.studID + ord('A'))} to club {min_node.clubID}")

def find_min_cost(cost_mat):

    pq = CustomHeap()
    assigned = [False] * N

    root = new_node(-1,-1, assigned, None)
    root.pathCost = root.cost = 0
    root.studID =-1

    pq.push(root)

    while True:
        min_node = pq.pop()
        stud = min_node.studID + 1

        if stud == N:
            print_assignmts(min_node)

            return min_node.cost

        for club in range(N):

            if not min_node.assigned[club]:

                child = new_node(stud, club, min_node.assigned, min_node)
                child.pathCost = min_node.pathCost + cost_mat[stud][club]
                child.cost = child.pathCost + calc_cost(cost_mat, stud, club, child.assigned)

                pq.push(child)


if __name__ == "__main__":

    N = int(input("Enter num of students and clubs: "))
    cost_mat = []

    print("Enter cost mat row by row:")

    for i in range(N):
        row = list(map(int, input(f"Row {i + 1}: ").split()))

        if len(row) != N:
            print("Error: Each row must contain same num of elements as the number of clubs.")
            exit()
        cost_mat.append(row)

    optimal_cost = find_min_cost(cost_mat)

    if optimal_cost is not None:
        print(f"\nOptimal cost is {optimal_cost}")
    else:
        print("\nNo optimal solution found.")

"""
Time and Space Complexity : O(N^2 log N)
"""